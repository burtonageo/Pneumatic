#version 330

layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec4 color;
layout(location = 2) in vec2 texCoord;
layout(location = 3) in vec3 normal;

out Vertex	{
  vec4 color;
  vec2 texCoord;
  vec3 normal; 
} OUT;

uniform mat4 MVP;
uniform float time;
uniform float rotAngle;

// taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/
mat4 rotationMatrix4(vec3 axis, float angle)
{
  axis = normalize(axis);
  float s = sin(angle);
  float c = cos(angle);
  float oc = 1.0 - c;

  return mat4(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,
              oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s, 0.0,
              oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c,          0.0,
              0.0,                               0.0,                               0.0,                               1.0);
}

void main()
{ 
  float locRotAngle = max(sin(rotAngle), rotAngle) + rotAngle + sin(rotAngle);
  vec4 worldPos = vec4(vertexPosition_modelspace, 1.0);
  worldPos.y += sin(time);
  gl_Position  = MVP * rotationMatrix4(vec3(0, 1, 0), locRotAngle) * worldPos;
  OUT.color    = color;
  vec2 oTexCoord = texCoord;
  oTexCoord.x -= 0.5;
  oTexCoord.y -= 0.5;
  OUT.texCoord = oTexCoord * abs(sin(time)) + 0.5;
  OUT.normal = normal;
}
